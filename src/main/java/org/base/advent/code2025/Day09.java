package org.base.advent.code2025;

import org.apache.commons.lang3.tuple.Pair;
import org.base.advent.util.Point;

import java.util.*;
import java.util.function.Function;

import static java.lang.Math.*;


/**
 * <a href="https://adventofcode.com/2025/day/9">Day 9</a>
 */
public class Day09 implements Function<List<String>, Pair<Long, Long>> {
    record Rectangle(Point a, Point b) {
        long area() {
            return (abs(a.x - b.x) + 1L) * (abs(a.y - b.y) + 1L);
        }
    }
    static class Polygon {
        List<Point> points;
        Set<Long> hitsCache = new HashSet<>(), missesCache = new HashSet<>();

        public Polygon(List<Point> points) {
            this.points = points;
        }

        boolean doesNotContain(Point pt) {
            long key = (pt.x << 32) | (pt.y & 0xFFFFFFFFL);
            if (hitsCache.contains(key)) return false;
            if (missesCache.contains(key)) return true;
            if (!containsAoc(points, pt)) {
                missesCache.add(key);
                return true;
            }
            else {
                hitsCache.add(key);
                return false;
            }
        }
    }

    @Override
    public Pair<Long, Long> apply(List<String> input) {
        List<Point> points = input.stream().map(Point::point).toList();
        PriorityQueue<Rectangle> queue = new PriorityQueue<>(
                Comparator.comparingLong(Rectangle::area).reversed());

        for (int i = 0; i < points.size(); i++) {
            for (int j = i + 1; j < points.size(); j++) {
                Point a = points.get(i);
                Point b = points.get(j);
                queue.offer(new Rectangle(a, b));
            }
        }

        if (queue.isEmpty())
            return Pair.of(-1L, -1L);

        long part1 = queue.poll().area();

        Polygon polygon = new Polygon(points);
        long polyMinX = points.stream().mapToLong(p -> p.x).min().orElse(0);
        long polyMaxX = points.stream().mapToLong(p -> p.x).max().orElse(0);
        long polyMinY = points.stream().mapToLong(p -> p.y).min().orElse(0);
        long polyMaxY = points.stream().mapToLong(p -> p.y).max().orElse(0);
        // Calculate polygon dimensions
        long polyWidth = polyMaxX - polyMinX;
        long polyHeight = polyMaxY - polyMinY;
        long maxReasonableArea = polyWidth * polyHeight / 5;  // Heuristic

        long part2 = 0;
        outer: while (!queue.isEmpty()) {
            Rectangle rect = queue.poll();
            // Skip if area is impossibly large
            if (rect.area() > maxReasonableArea)
                continue;

            long minX = min(rect.a.x, rect.b.x), maxX = max(rect.a.x, rect.b.x);
            long minY = min(rect.a.y, rect.b.y), maxY = max(rect.a.y, rect.b.y);
            // Skip if rectangle extends outside polygon bounds
            if (minX < polyMinX || maxX > polyMaxX || minY < polyMinY || maxY > polyMaxY)
                continue;
            if (polygon.doesNotContain(Point.of(minX, minY)) ||
                    polygon.doesNotContain(Point.of(maxX, minY)) ||
                    polygon.doesNotContain(Point.of(minX, maxY)) ||
                    polygon.doesNotContain(Point.of(maxX, maxY))) {
                continue;
            }

            // check rectangle edges
            for (long x = minX; x <= maxX; x++) {
                Point lowY = Point.of(x, minY);
                if (polygon.doesNotContain(lowY))
                    continue outer;
                Point highY = Point.of(x, maxY);
                if (polygon.doesNotContain(highY))
                    continue outer;
            }
            for (long y = minY + 1; y < maxY; y++) {
                Point lowX = Point.of(minX, y);
                if (polygon.doesNotContain(lowX))
                    continue outer;
                Point highX = Point.of(maxX, y);
                if (polygon.doesNotContain(highX))
                    continue outer;
            }

            long centerX = (minX + maxX) / 2;
            long centerY = (minY + maxY) / 2;
            if (polygon.doesNotContain(Point.of(centerX, centerY))) {
                continue;
            }

            part2 = rect.area();
            break;
        }

        return Pair.of(part1, part2);
    }

    // the following methods were generated by claude.ai

    static boolean containsAoc(List<Point> polygon, Point test) {
        int n = polygon.size();
        for (int i = 0; i < n; i++) {
            Point p1 = polygon.get(i);
            if (p1.equals(test))
                return true;

            Point p2 = polygon.get((i + 1) % n);
            if (isOnSegment(p1, p2, test)) {
                return true;  // Points on edges are inside
            }
        }

        // ray casting for interior points
        boolean inside = false;
        for (int i = 0, j = n - 1; i < n; j = i++) {
            Point pi = polygon.get(i);
            Point pj = polygon.get(j);

            if ((pi.y > test.y) != (pj.y > test.y) &&
                    test.x < (pj.x - pi.x) * (test.y - pi.y) / (pj.y - pi.y) + pi.x) {
                inside = !inside;
            }
        }

        return inside;
    }

    private static boolean isOnSegment(Point p1, Point p2, Point test) {
        // Check if test point is on line segment p1-p2
        long minX = Math.min(p1.x, p2.x);
        long maxX = Math.max(p1.x, p2.x);
        long minY = Math.min(p1.y, p2.y);
        long maxY = Math.max(p1.y, p2.y);

        // Point must be within bounding box
        if (test.x < minX || test.x > maxX || test.y < minY || test.y > maxY) {
            return false;
        }

        // Check if point is collinear with segment
        long cross = (test.y - p1.y) * (p2.x - p1.x) - (test.x - p1.x) * (p2.y - p1.y);
        return cross == 0;
    }
}

